diff --git a/machine/encoding.h b/machine/encoding.h
index a9de9ef..208ec9b 100644
--- a/machine/encoding.h
+++ b/machine/encoding.h
@@ -3183,6 +3183,7 @@
 #define CSR_MHPMCOUNTER29H 0xb9d
 #define CSR_MHPMCOUNTER30H 0xb9e
 #define CSR_MHPMCOUNTER31H 0xb9f
+#define CSR_MCX_TABLE 0x802
 #define CAUSE_MISALIGNED_FETCH 0x0
 #define CAUSE_FETCH_ACCESS 0x1
 #define CAUSE_ILLEGAL_INSTRUCTION 0x2
@@ -4810,6 +4811,8 @@ DECLARE_CSR(mhpmcounter28h, CSR_MHPMCOUNTER28H)
 DECLARE_CSR(mhpmcounter29h, CSR_MHPMCOUNTER29H)
 DECLARE_CSR(mhpmcounter30h, CSR_MHPMCOUNTER30H)
 DECLARE_CSR(mhpmcounter31h, CSR_MHPMCOUNTER31H)
+DECLARE_CSR(mcx_table, CSR_MCX_TABLE)
+
 #endif
 #ifdef DECLARE_CAUSE
 DECLARE_CAUSE("misaligned fetch", CAUSE_MISALIGNED_FETCH)
@@ -7705,6 +7708,7 @@ DECLARE_CAUSE("store guest page fault", CAUSE_STORE_GUEST_PAGE_FAULT)
 #define CSR_MHPMCOUNTER29H 0xb9d
 #define CSR_MHPMCOUNTER30H 0xb9e
 #define CSR_MHPMCOUNTER31H 0xb9f
+#define CSR_MCX_TABLE 0x802
 #define CAUSE_MISALIGNED_FETCH 0x0
 #define CAUSE_FETCH_ACCESS 0x1
 #define CAUSE_ILLEGAL_INSTRUCTION 0x2
@@ -9332,6 +9336,7 @@ DECLARE_CSR(mhpmcounter28h, CSR_MHPMCOUNTER28H)
 DECLARE_CSR(mhpmcounter29h, CSR_MHPMCOUNTER29H)
 DECLARE_CSR(mhpmcounter30h, CSR_MHPMCOUNTER30H)
 DECLARE_CSR(mhpmcounter31h, CSR_MHPMCOUNTER31H)
+DECLARE_CSR(mcx_table, CSR_MCX_TABLE)
 #endif
 #ifdef DECLARE_CAUSE
 DECLARE_CAUSE("misaligned fetch", CAUSE_MISALIGNED_FETCH)
@@ -12227,6 +12232,7 @@ DECLARE_CAUSE("store guest page fault", CAUSE_STORE_GUEST_PAGE_FAULT)
 #define CSR_MHPMCOUNTER29H 0xb9d
 #define CSR_MHPMCOUNTER30H 0xb9e
 #define CSR_MHPMCOUNTER31H 0xb9f
+#define CSR_MCX_TABLE 0x802
 #define CAUSE_MISALIGNED_FETCH 0x0
 #define CAUSE_FETCH_ACCESS 0x1
 #define CAUSE_ILLEGAL_INSTRUCTION 0x2
@@ -13854,6 +13860,7 @@ DECLARE_CSR(mhpmcounter28h, CSR_MHPMCOUNTER28H)
 DECLARE_CSR(mhpmcounter29h, CSR_MHPMCOUNTER29H)
 DECLARE_CSR(mhpmcounter30h, CSR_MHPMCOUNTER30H)
 DECLARE_CSR(mhpmcounter31h, CSR_MHPMCOUNTER31H)
+DECLARE_CSR(mcx_table, CSR_MCX_TABLE)
 #endif
 #ifdef DECLARE_CAUSE
 DECLARE_CAUSE("misaligned fetch", CAUSE_MISALIGNED_FETCH)
diff --git a/machine/mentry.S b/machine/mentry.S
index 4cf9685..7f6d139 100644
--- a/machine/mentry.S
+++ b/machine/mentry.S
@@ -272,6 +272,10 @@ do_reset:
   csrr t1, mtvec
 1:bne t0, t1, 1b
 
+  # allows us to allocate 4096 bits for the cx_table
+  
+  # la t0, 0x7FFFFF00
+  # csrw 0x802, t0
   la sp, stacks + RISCV_PGSIZE - MENTRY_FRAME_SIZE
 
   csrr a3, mhartid
diff --git a/pk/mmap.c b/pk/mmap.c
index dd0fe59..4c70593 100644
--- a/pk/mmap.c
+++ b/pk/mmap.c
@@ -26,6 +26,8 @@ static vmr_t* vmr_freelist_head;
 
 static pte_t* root_page_table;
 
+static pte_t* cx_table;
+
 #define RISCV_PGLEVELS ((VA_BITS - RISCV_PGSHIFT) / RISCV_PGLEVEL_BITS)
 
 static spinlock_t vm_lock = SPINLOCK_INIT;
@@ -566,6 +568,10 @@ uintptr_t pk_vm_init()
   size_t num_freelist_nodes = mem_size / RISCV_PGSIZE;
   page_freelist_storage = (freelist_node_t*)__early_alloc(num_freelist_nodes * sizeof(freelist_node_t));
 
+  cx_table = (void*)__page_alloc_assert();
+
+  write_csr(0x802, (uintptr_t)cx_table);
+
   root_page_table = (void*)__page_alloc_assert();
   __map_kernel_range(KVA_START, MEM_START, mem_size, PROT_READ|PROT_WRITE|PROT_EXEC);
 
@@ -578,6 +584,7 @@ uintptr_t pk_vm_init()
   kva2pa_offset = KVA_START - MEM_START;
   page_freelist_storage = (void*)pa2kva(page_freelist_storage);
   root_page_table = (void*)pa2kva(root_page_table);
+  cx_table = (void*)pa2kva(cx_table);
 
   return kernel_stack_top;
 }
diff --git a/pk/pk.c b/pk/pk.c
index b8c9337..c0c009f 100644
--- a/pk/pk.c
+++ b/pk/pk.c
@@ -11,6 +11,9 @@
 #include "flush_icache.h"
 #include <stdbool.h>
 
+#define MCX_TABLE_NUM_ELEMENTS 1024
+#define MCX_TABLE_SIZE MCX_TABLE_NUM_ELEMENTS * sizeof(int)
+
 elf_info current;
 long disabled_hart_mask;
 
@@ -100,6 +103,7 @@ static void run_loaded_program(size_t argc, char** argv, uintptr_t kstack_top)
 
   // copy phdrs to user stack
   size_t stack_top = current.stack_top - current.phdr_size;
+
   memcpy_to_user((void*)stack_top, (void*)current.phdr, current.phdr_size);
   current.phdr = stack_top;
 
@@ -140,6 +144,17 @@ static void run_loaded_program(size_t argc, char** argv, uintptr_t kstack_top)
     {AT_NULL, 0}
   };
 
+  // I don't think this is needed - honestly not sure what the point of these
+  // copys to user stack do, as it's done again in STACK_INIT();
+
+  // int cx_table[MCX_TABLE_NUM_ELEMENTS] = {0};
+  // for (size_t i = 0; i < MCX_TABLE_NUM_ELEMENTS; i++) {
+  //   size_t len = sizeof(int);
+  //   stack_top -= len;
+  //   // memcpy_to_user((void*)stack_top, &cx_table[i], len);
+  //   // cx_table[i] = (void*)stack_top;
+  // }
+
   // place argc, argv, envp, auxp on stack
   #define PUSH_ARG(type, value) do { \
     type __tmp = (type)(value); \
@@ -163,7 +178,13 @@ static void run_loaded_program(size_t argc, char** argv, uintptr_t kstack_top)
       PUSH_ARG(type, aux[i].key); \
       PUSH_ARG(type, aux[i].value); \
     } \
-  } while (0)
+    stack_top -= (MCX_TABLE_NUM_ELEMENTS) * sizeof(type); \
+    stack_top &= -MCX_TABLE_SIZE; \
+    sp = (void*)stack_top; \
+    for (unsigned i = 0; i < MCX_TABLE_NUM_ELEMENTS; i++) { \
+      PUSH_ARG(type, 0x08000000); \
+    } \
+  } while (0)     
 
   STACK_INIT(uintptr_t);
 
@@ -173,10 +194,17 @@ static void run_loaded_program(size_t argc, char** argv, uintptr_t kstack_top)
     current.instret0 = rdinstret64();
   }
 
+  // 0x802 is mcx_table
+  // write_csr(0x802, stack_top);
+  // stack_top &= -16;
+
   trapframe_t tf;
   init_tf(&tf, current.entry, stack_top);
   __riscv_flush_icache();
   write_csr(sscratch, kstack_top);
+  
+  // printk("stack_size: %08x, stack_bottom: %08x, kstack_top: %08x, stack_top: %08x, final stack_top: %08x\n", stack_size, stack_bottom, current.stack_top, kstack_top, stack_top);
+
   start_user(&tf);
 }
 
diff --git a/pk/syscall.c b/pk/syscall.c
index bda4393..2d65d7b 100644
--- a/pk/syscall.c
+++ b/pk/syscall.c
@@ -1,5 +1,6 @@
 // See LICENSE for license details.
 
+#include "atomic.h"
 #include "syscall.h"
 #include "pk.h"
 #include "file.h"
@@ -13,6 +14,8 @@
 
 typedef long (*syscall_t)(long, long, long, long, long, long, long);
 
+static spinlock_t vm_lock = SPINLOCK_INIT;
+
 #define CLOCK_FREQ 1000000000
 
 #define MAX_BUF 512
@@ -531,6 +534,7 @@ int sys_gettimeofday(long* loc)
 
 long sys_clock_gettime(int clk_id, long *loc)
 {
+  printk("clk_id: %d, loc: %08x\n", clk_id, loc);
   uint64_t t = rdcycle64();
 
   long kloc[2];
@@ -587,6 +591,27 @@ static int sys_stub_nosys()
   return -ENOSYS;
 }
 
+void sys_cx_open(int cx_guid) {
+  uint32_t *mcx_table_p = (uint32_t *)read_csr(0x802);
+
+  int temp = cx_guid;
+  int *cx_guid_p = &temp;
+
+  spinlock_lock(&vm_lock);
+  
+  // This should be copying to the physical address as well
+  // kva2pa?
+  
+  memcpy_to_user(mcx_table_p, cx_guid_p, sizeof(cx_guid));
+  
+  spinlock_unlock(&vm_lock);
+  
+}
+
+int sys_cx_close(int cx_sel) {
+  return 0;
+}
+
 long do_syscall(long a0, long a1, long a2, long a3, long a4, long a5, unsigned long n)
 {
   const static void* syscall_table[] = {
@@ -632,6 +657,8 @@ long do_syscall(long a0, long a1, long a2, long a3, long a4, long a5, unsigned l
     [SYS_rt_sigprocmask] = sys_stub_success,
     [SYS_clock_gettime] = sys_clock_gettime,
     [SYS_chdir] = sys_chdir,
+    [SYS_cx_open] = sys_cx_open,
+    [SYS_cx_close] = sys_cx_close,
   };
 
   const static void* old_syscall_table[] = {
diff --git a/pk/syscall.h b/pk/syscall.h
index 31fb3be..a886a6b 100644
--- a/pk/syscall.h
+++ b/pk/syscall.h
@@ -58,6 +58,8 @@
 #define SYS_set_robust_list 99
 #define SYS_madvise 233
 #define SYS_statx 291
+#define SYS_cx_open 51
+#define SYS_cx_close 52
 
 #define OLD_SYSCALL_THRESHOLD 1024
 #define SYS_open 1024
