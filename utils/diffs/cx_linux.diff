diff --git a/Kbuild b/Kbuild
index 464b34a08f51..64a2bfedd213 100644
--- a/Kbuild
+++ b/Kbuild
@@ -97,3 +97,5 @@ obj-$(CONFIG_SAMPLES)	+= samples/
 obj-$(CONFIG_NET)	+= net/
 obj-y			+= virt/
 obj-y			+= $(ARCH_DRIVERS)
+obj-y           += cx_sys/
+
diff --git a/arch/riscv/include/asm/asm-prototypes.h b/arch/riscv/include/asm/asm-prototypes.h
index 36b955c762ba..637cd642e6cc 100644
--- a/arch/riscv/include/asm/asm-prototypes.h
+++ b/arch/riscv/include/asm/asm-prototypes.h
@@ -24,6 +24,7 @@ DECLARE_DO_ERROR_INFO(do_trap_ecall_u);
 DECLARE_DO_ERROR_INFO(do_trap_ecall_s);
 DECLARE_DO_ERROR_INFO(do_trap_ecall_m);
 DECLARE_DO_ERROR_INFO(do_trap_break);
+DECLARE_DO_ERROR_INFO(do_trap_first_cx_use);
 
 asmlinkage void handle_bad_stack(struct pt_regs *regs);
 asmlinkage void do_page_fault(struct pt_regs *regs);
diff --git a/arch/riscv/kernel/traps.c b/arch/riscv/kernel/traps.c
index a1b9be3c4332..ba8aa9062863 100644
--- a/arch/riscv/kernel/traps.c
+++ b/arch/riscv/kernel/traps.c
@@ -32,6 +32,8 @@
 #include <asm/vector.h>
 #include <asm/irq_stack.h>
 
+#include "../../../../research/riscv-tools/cx_runtime/include/utils.h"
+
 int show_unhandled_signals = 1;
 
 static DEFINE_SPINLOCK(die_lock);
@@ -113,7 +115,6 @@ void die(struct pt_regs *regs, const char *str)
 void do_trap(struct pt_regs *regs, int signo, int code, unsigned long addr)
 {
 	struct task_struct *tsk = current;
-
 	if (show_unhandled_signals && unhandled_signal(tsk, signo)
 	    && printk_ratelimit()) {
 		pr_info("%s[%d]: unhandled signal %d code 0x%x at 0x" REG_FMT,
@@ -169,6 +170,14 @@ DO_ERROR_INFO(do_trap_insn_fault,
 asmlinkage __visible __trap_section void do_trap_insn_illegal(struct pt_regs *regs)
 {
 	bool handled;
+	u32 insn = (u32)regs->badaddr;
+	uint opc = insn & ((1<<7)-1);
+	
+	if (opc == CX_REG_TYPE || opc == CX_IMM_TYPE || opc == CX_FLEX_TYPE) {
+		do_trap_first_cx_use(regs);
+		return;
+	}
+
 
 	if (user_mode(regs)) {
 		irqentry_enter_from_user_mode(regs);
@@ -339,6 +348,23 @@ asmlinkage __visible __trap_section void do_trap_ecall_u(struct pt_regs *regs)
 
 }
 
+/* TODO (cx, Brandon): This is incredibly hacky - Used for virtualization of state. */
+asmlinkage __visible __trap_section void do_trap_first_cx_use(struct pt_regs *regs)
+{
+	long syscall = 461;
+
+	regs->orig_a0 = regs->a0;
+
+	riscv_v_vstate_discard(regs);
+
+	if (syscall >= 0 && syscall < NR_syscalls)
+		syscall_handler(regs, syscall);
+	else if (syscall != -1)
+		regs->a0 = -ENOSYS;
+
+	syscall_exit_to_user_mode(regs);
+}
+
 #ifdef CONFIG_MMU
 asmlinkage __visible noinstr void do_page_fault(struct pt_regs *regs)
 {
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 292c31697248..5d0f704ecd27 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -39,6 +39,8 @@
 #include <linux/livepatch_sched.h>
 #include <asm/kmap_size.h>
 
+#include <linux/queue.h>
+
 /* task_struct member predeclarations (sorted alphabetically): */
 struct audit_context;
 struct bio_list;
@@ -743,6 +745,26 @@ struct kmap_ctrl {
 #endif
 };
 
+typedef uint cx_stare_t;
+
+typedef struct {
+  cx_stare_t share;
+  uint ctx_status;
+  uint size;
+  int *data;
+} cx_os_state_t;
+
+typedef struct {
+  // static
+  int cx_guid;
+  int num_states;
+
+  // dynamic
+  int *counter;
+  int *index; // For stateless cxus ONLY - stores the cx_index
+  queue_t *avail_state_ids;
+} cx_entry_t;
+
 struct task_struct {
 #ifdef CONFIG_THREAD_INFO_IN_TASK
 	/*
@@ -1544,6 +1566,16 @@ struct task_struct {
 	struct user_event_mm		*user_event_mm;
 #endif
 
+	uint cx_status;
+	uint cx_index;
+	uint *mcx_table;
+	cx_os_state_t *cx_os_state_table;
+
+	queue_t *cx_table_avail_indices;
+	
+	// TODO: This shouldn't be here - should be in the device_struct.
+	// cx_entry_t cx_map[NUM_CX];
+
 	/*
 	 * New fields for task_struct should be added above here, so that
 	 * they are included in the randomized portion of task_struct.
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index fd9d12de7e92..81ac5f3406be 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -1279,4 +1279,11 @@ int __sys_getsockopt(int fd, int level, int optname, char __user *optval,
 		int __user *optlen);
 int __sys_setsockopt(int fd, int level, int optname, char __user *optval,
 		int optlen);
+
+long sys_cx_open(int cx_guid);
+long sys_cx_close(int cx_sel);
+// long __riscv_sys_context_restore(void);
+// long __riscv_sys_context_save(void);
+// long sys_cx_first_use(void);
+
 #endif
diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index 756b013fb832..81e95ed4d5b2 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -828,9 +828,19 @@ __SYSCALL(__NR_futex_wake, sys_futex_wake)
 __SYSCALL(__NR_futex_wait, sys_futex_wait)
 #define __NR_futex_requeue 456
 __SYSCALL(__NR_futex_requeue, sys_futex_requeue)
+#define __NR_cx_open 457
+__SYSCALL(__NR_cx_open, sys_cx_open)
+#define __NR_cx_close 458
+__SYSCALL(__NR_cx_close, sys_cx_close)
+#define __NR_context_save 459
+__SYSCALL(__NR_context_save, sys_context_save)
+#define __NR_context_restore 460
+__SYSCALL(__NR_context_restore, sys_context_restore)
+#define __NR_do_nothing 461
+__SYSCALL(__NR_do_nothing, sys_do_nothing)
 
 #undef __NR_syscalls
-#define __NR_syscalls 457
+#define __NR_syscalls 462
 
 /*
  * 32 bit systems traditionally used different
diff --git a/init/init_task.c b/init/init_task.c
index 5727d42149c3..100c662effbe 100644
--- a/init/init_task.c
+++ b/init/init_task.c
@@ -213,6 +213,10 @@ struct task_struct init_task
 };
 EXPORT_SYMBOL(init_task);
 
+#define NUM_CX 4
+cx_entry_t cx_map[NUM_CX];
+EXPORT_SYMBOL(cx_map);
+
 /*
  * Initial thread structure. Alignment of this is handled by a special
  * linker map entry.
diff --git a/init/main.c b/init/main.c
index e24b0780fdff..fdd73ed46d3a 100644
--- a/init/main.c
+++ b/init/main.c
@@ -111,6 +111,93 @@
 
 #include <kunit/test.h>
 
+#include "../../../../research/riscv-tools/cx_runtime/include/utils.h"
+#include "../../../../research/riscv-tools/cx_runtime/zoo/mulacc/mulacc_common.h"
+#include "../../../../research/riscv-tools/cx_runtime/zoo/muldiv/muldiv_common.h"
+#include "../../../../research/riscv-tools/cx_runtime/zoo/addsub/addsub_common.h"
+#include "../../../../research/riscv-tools/cx_runtime/zoo/p-ext/p-ext_common.h"
+
+extern cx_entry_t cx_map[NUM_CX];
+
+static int cx_init_process(void) {
+	current->mcx_table = kzalloc(sizeof(int) * CX_SEL_TABLE_NUM_ENTRIES, GFP_KERNEL);
+	if (!current->mcx_table) {
+			// some sort of allocation error here
+			return -1;
+	}
+	current->cx_os_state_table = (cx_os_state_t *)kzalloc(sizeof(cx_os_state_t) * CX_SEL_TABLE_NUM_ENTRIES, GFP_KERNEL);
+	if (!current->cx_os_state_table) {
+			// some sort of allocation error here
+			return -1;
+	}
+
+	// TODO: Check for successful allocation
+	current->cx_table_avail_indices = make_queue(CX_SEL_TABLE_NUM_ENTRIES);
+
+	// 1st slot in table is canonical legacy value
+	current->mcx_table[0] = CX_LEGACY;
+	dequeue(current->cx_table_avail_indices);
+
+	for (int i = 1; i < CX_SEL_TABLE_NUM_ENTRIES; i++) {
+		current->mcx_table[i] = CX_INVALID_SELECTOR;
+	}
+
+	// Update the mcx_table csr with the mcx_table address
+	csr_write(MCX_TABLE, &current->mcx_table[0]);
+
+	// 0 initialize the cx_index table csr
+	csr_write(CX_INDEX, 0);
+
+	// 0 initialize the mcx_selector csr
+	csr_write(MCX_SELECTOR, 0);
+
+	// 0 initialize the cx_status csr
+	csr_write(CX_STATUS, 0);
+
+	return 0;
+}
+
+int cx_init(void) {
+        pr_info("Ran in part of main\n");
+        if (cx_init_process() < 0) {
+			return -1;
+		}
+
+        cx_map[0].cx_guid = CX_GUID_MULDIV;
+        cx_map[1].cx_guid = CX_GUID_ADDSUB;
+        cx_map[2].cx_guid = CX_GUID_MULACC;
+        cx_map[3].cx_guid = CX_GUID_PEXT;
+
+        cx_map[0].num_states = CX_MULDIV_NUM_STATES;
+        cx_map[1].num_states = CX_ADDSUB_NUM_STATES;
+        cx_map[2].num_states = CX_MULACC_NUM_STATES;
+        cx_map[3].num_states = CX_PEXT_NUM_STATES;
+
+        int32_t num_states = -1;
+
+        for (int i = 0; i < NUM_CX; i++) {
+
+                num_states = cx_map[i].num_states;
+
+                // stateless cxu
+                if (num_states == 0) {
+                        cx_map[i].index = kzalloc(sizeof(int) * 1, GFP_KERNEL);
+                        cx_map[i].counter = kzalloc(sizeof(int) * 1, GFP_KERNEL);
+
+                        cx_map[i].index[0] = -1;
+                }
+                // stateful cxu
+                else {
+                        // cx_map[i].index = kzalloc(sizeof(int) * 1, GFP_KERNEL);
+                        cx_map[i].counter = kzalloc(sizeof(int) * num_states, GFP_KERNEL);
+                        cx_map[i].avail_state_ids = make_queue(num_states);
+                }
+        }
+
+        return 0;
+}
+
+
 static int kernel_init(void *);
 
 /*
@@ -670,6 +757,7 @@ static void __init setup_command_line(char *command_line)
 	saved_command_line_len = strlen(saved_command_line);
 }
 
+
 /*
  * We need to finalize in a non-__init function or else race conditions
  * between the root thread and the init thread may cause start_kernel to
@@ -693,6 +781,7 @@ noinline void __ref __noreturn rest_init(void)
 	 * we schedule it before we create kthreadd, will OOPS.
 	 */
 	pid = user_mode_thread(kernel_init, NULL, CLONE_FS);
+
 	/*
 	 * Pin init on the boot CPU. Task migration is not properly working
 	 * until sched_init_smp() has been run. It will set the allowed
@@ -727,7 +816,9 @@ noinline void __ref __noreturn rest_init(void)
 	 */
 	schedule_preempt_disabled();
 	/* Call into cpu_idle with preempt disabled */
+
 	cpu_startup_entry(CPUHP_ONLINE);
+
 }
 
 /* Check for early params. */
@@ -1462,9 +1553,10 @@ static int __ref kernel_init(void *unused)
 	rcu_end_inkernel_boot();
 
 	do_sysctl_args();
-
 	if (ramdisk_execute_command) {
 		ret = run_init_process(ramdisk_execute_command);
+		cx_init();
+		pr_info("init pid: %d\n", current->pid);
 		if (!ret)
 			return 0;
 		pr_err("Failed to execute %s (error %d)\n",
diff --git a/lib/Makefile b/lib/Makefile
index 6b09731d8e61..a1f08d1ea3bf 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -411,6 +411,8 @@ obj-$(CONFIG_GENERIC_LIB_DEVMEM_IS_ALLOWED) += devmem_is_allowed.o
 
 obj-$(CONFIG_FIRMWARE_TABLE) += fw_table.o
 
+obj-y += queue.o
+
 # FORTIFY_SOURCE compile-time behavior tests
 TEST_FORTIFY_SRCS = $(wildcard $(srctree)/$(src)/test_fortify/*-*.c)
 TEST_FORTIFY_LOGS = $(patsubst $(srctree)/$(src)/%.c, %.log, $(TEST_FORTIFY_SRCS))
